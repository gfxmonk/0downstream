<?xml version="1.0" ?>
<?xml-stylesheet type='text/xsl' href='interface.xsl'?>
<interface uri="http://gfxmonk.github.io/0downstream/feeds/pypi/dnslib.xml" xmlns="http://zero-install.sourceforge.net/2004/injector/interface" xmlns:compile="http://zero-install.sourceforge.net/2006/namespaces/0compile" xmlns:gfxmonk="http://gfxmonk.net/dist/0install">
	<implementation id="sha1new=9cf696f418f40704fc06e71b429c141b2bad3e15" version="0.9.3">
		<environment insert="" mode="prepend" name="PYTHONPATH"/>
		<requires interface="http://repo.roscidus.com/python/python"/>
		<archive extract="dnslib-0.9.3" href="https://pypi.python.org/packages/source/d/dnslib/dnslib-0.9.3.tar.gz" size="60854"/>
		<manifest-digest sha256="088b2b0cf236814570d9f68d49ddb27fd7ce7e880a432ab8b9e34ca627ba044f"/>
	</implementation>
	<name>dnslib</name>
	<summary>Simple library to encode/decode DNS wire-format packets</summary>
	<homepage>http://bitbucket.org/paulc/dnslib/</homepage>
	<description>dnslib
------

A library to encode/decode DNS wire-format packets supporting both 
Python 2.7 and Python 3.2+.

The library provides:

 * Support for encoding/decoding DNS packets between wire format,
   python objects, and Zone/DiG textual representation (dnslib.dns)

 * A server framework allowing the simple creation of custom DNS 
   resolvers (dnslib.server) and a number of example servers 
   created using this frameowork

 * A number of utilities for testing (dnslib.client, dnslib.proxy,
   dnslib.intercept)

Python 3 support was added in Version 0.9.0 which represented a fairly
major update to the library - the key changes include:

 * Python 2.7/3.2+ support (the last version supporting Python 2.6 
   or earlier was version 0.8.3)

 * The 'Bimap' interface was changed significantly to explicitly 
   split forward (value-&gt;text) lookups via __getitem__ and 
   reverse (text-&gt;value) lookups via __getattr__. Applications
   using the old interface will need to be updated.

 * Hostnames are now returned with a trailing dot by default (in
   line with RFC)

 * Most object attributes are now typed in line with the record
   definitions to make it harder to generate invalid packets 

 * Support for encoding/decoding resource records in 'Zone' (BIND) 
   file format 

 * Support for encoding/decoding backets in 'DiG' format

 * Server framework allowing (in most cases) custom resolvers to
   be created by just subclassing the DNSResolver class and 
   overringing the 'resolve' method

 * A lot of fixes to error detection/handling which should make 
   the library much more robust to invalid/unsupported data. The
   library should now either return a valid DNSRecord instance
   when parsing a packet or raise DNSError (tested via fuzzing)

 * Improved utilities (dnslib.client, dnslib.proxy, dnslib.intercept)

 * Improvements to encoding/decoding tests including the ability
   to generate test data automatically in test_decode.py (comparing
   outputs against DiG)

 * Ability to compare and diff DNSRecords

This is a large release and despite the testing there therefore are likely
to be some bugs. Once the 0.9 release is sufficiently stable I would expect
to release as 1.0.0 (and stabilise th api)

The key DNS packet handling classes are in dnslib.dns and map to the 
standard DNS packet sections:

 * DNSRecord - container for DNS packet. Contains:
    - DNSHeader 
    - Question section containing zero or more DNSQuestion objects 
    - Answer section containing zero or more RR objects 
    - Authority section containing zero or more RR objects 
    - Additional section containing zero or more RR objects 
 * DNS RRs (resource records) contain an RR header and an RD object)
 * Specific RD types are implemented as subclasses of RD
 * DNS labels are represented by a DNSLabel class - in most cases
   this handles conversion to/from textual representation however
   does support arbitatry labels via a tuple of bytes objects)

Version 0.9 of the library was a major rewrite to support Python 3.2+ 
(retaining support for Python 2.7+). As part of the Py3 changes a 
number of other significant changes were intrtoduced:

- Much better error handling (packet decoding errors should be 
  caught and DNSError raised)

Usage:
------

To decode a DNS packet:

    &gt;&gt;&gt; packet = binascii.unhexlify(b'd5ad818000010005000000000377777706676f6f676c6503636f6d0000010001c00c0005000100000005000803777777016cc010c02c0001000100000005000442f95b68c02c0001000100000005000442f95b63c02c0001000100000005000442f95b67c02c0001000100000005000442f95b93')
    &gt;&gt;&gt; d = DNSRecord.parse(packet)
    &gt;&gt;&gt; d
    &lt;DNS Header: id=0xd5ad type=RESPONSE opcode=QUERY flags=RD,RA rcode='NOERROR' q=1 a=5 ns=0 ar=0&gt;
    &lt;DNS Question: 'www.google.com.' qtype=A qclass=IN&gt;
    &lt;DNS RR: 'www.google.com.' rtype=CNAME rclass=IN ttl=5 rdata='www.l.google.com.'&gt;
    &lt;DNS RR: 'www.l.google.com.' rtype=A rclass=IN ttl=5 rdata='66.249.91.104'&gt;
    &lt;DNS RR: 'www.l.google.com.' rtype=A rclass=IN ttl=5 rdata='66.249.91.99'&gt;
    &lt;DNS RR: 'www.l.google.com.' rtype=A rclass=IN ttl=5 rdata='66.249.91.103'&gt;
    &lt;DNS RR: 'www.l.google.com.' rtype=A rclass=IN ttl=5 rdata='66.249.91.147'&gt;

The default text representation of the DNSRecord is in zone file format:

    &gt;&gt;&gt; print(d)
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 54701
    ;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 0
    ;; QUESTION SECTION:
    ;www.google.com.                IN      A
    ;; ANSWER SECTION:
    www.google.com.         5       IN      CNAME   www.l.google.com.
    www.l.google.com.       5       IN      A       66.249.91.104
    www.l.google.com.       5       IN      A       66.249.91.99
    www.l.google.com.       5       IN      A       66.249.91.103
    www.l.google.com.       5       IN      A       66.249.91.147

To create a DNS Request Packet:

    &gt;&gt;&gt; d = DNSRecord.question(&quot;google.com&quot;)

(This is equivalent to: d = DNSRecord(q=DNSQuestion(&quot;google.com&quot;) )

    &gt;&gt;&gt; d
    &lt;DNS Header: id=... type=QUERY opcode=QUERY flags=RD rcode='NOERROR' q=1 a=0 ns=0 ar=0&gt;
    &lt;DNS Question: 'google.com.' qtype=A qclass=IN&gt;

    &gt;&gt;&gt; str(DNSRecord.parse(d.pack())) == str(d)
    True

    &gt;&gt;&gt; print(d)
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...
    ;; flags: rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0
    ;; QUESTION SECTION:
    ;google.com.                    IN      A

    &gt;&gt;&gt; d = DNSRecord.question(&quot;google.com&quot;,&quot;MX&quot;)

(This is equivalent to: d = DNSRecord(q=DNSQuestion(&quot;google.com&quot;,QTYPE.MX) )

    &gt;&gt;&gt; str(DNSRecord.parse(d.pack())) == str(d)
    True

    &gt;&gt;&gt; print(d)
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...
    ;; flags: rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0
    ;; QUESTION SECTION:
    ;google.com.                    IN      MX

To create a DNS Response Packet:

    &gt;&gt;&gt; d = DNSRecord(DNSHeader(qr=1,aa=1,ra=1),
    ...               q=DNSQuestion(&quot;abc.com&quot;),
    ...               a=RR(&quot;abc.com&quot;,rdata=A(&quot;1.2.3.4&quot;)))
    &gt;&gt;&gt; d
    &lt;DNS Header: id=... type=RESPONSE opcode=QUERY flags=AA,RD,RA rcode='NOERROR' q=1 a=1 ns=0 ar=0&gt;
    &lt;DNS Question: 'abc.com.' qtype=A qclass=IN&gt;
    &lt;DNS RR: 'abc.com.' rtype=A rclass=IN ttl=0 rdata='1.2.3.4'&gt;
    &gt;&gt;&gt; str(DNSRecord.parse(d.pack())) == str(d)
    True

    &gt;&gt;&gt; print(d)
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...
    ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
    ;; QUESTION SECTION:
    ;abc.com.                       IN      A
    ;; ANSWER SECTION:
    abc.com.                0       IN      A       1.2.3.4

It is also possible to create RRs from a string in zone file format

    &gt;&gt;&gt; RR.fromZone(&quot;abc.com IN A 1.2.3.4&quot;)
    [&lt;DNS RR: 'abc.com.' rtype=A rclass=IN ttl=0 rdata='1.2.3.4'&gt;]

(Note: this produces a list of RRs which should be unpacked if being
    passed to add_answer/add_auth/add_ar etc)

    &gt;&gt;&gt; q = DNSRecord.question(&quot;abc.com&quot;)
    &gt;&gt;&gt; a = q.reply()
    &gt;&gt;&gt; a.add_answer(*RR.fromZone(&quot;abc.com 60 A 1.2.3.4&quot;))
    &gt;&gt;&gt; print(a)
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...
    ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
    ;; QUESTION SECTION:
    ;abc.com.                       IN      A
    ;; ANSWER SECTION:
    abc.com.                60      IN      A       1.2.3.4

The zone file can contain multiple entries and supports most of the normal
format defined in RFC1035 (specifically not $INCLUDE)

    &gt;&gt;&gt; z = '''
    ...         $TTL 300
    ...         $ORIGIN abc.com
    ...
    ...         @       IN      MX      10  mail.abc.com.
    ...         www     IN      A       1.2.3.4
    ...                 IN      TXT     &quot;Some Text&quot;
    ...         mail    IN      CNAME   www.abc.com.
    ... '''
    &gt;&gt;&gt; for rr in RR.fromZone(textwrap.dedent(z)):
    ...     print(rr)
    abc.com.                300     IN      MX      10 mail.abc.com.
    www.abc.com.            300     IN      A       1.2.3.4
    www.abc.com.            300     IN      TXT     &quot;Some Text&quot;
    mail.abc.com.           300     IN      CNAME   www.abc.com.

To create a skeleton reply to a DNS query:

    &gt;&gt;&gt; q = DNSRecord(q=DNSQuestion(&quot;abc.com&quot;,QTYPE.ANY)) 
    &gt;&gt;&gt; a = q.reply()
    &gt;&gt;&gt; a.add_answer(RR(&quot;abc.com&quot;,QTYPE.A,rdata=A(&quot;1.2.3.4&quot;),ttl=60))
    &gt;&gt;&gt; str(DNSRecord.parse(a.pack())) == str(a)
    True
    &gt;&gt;&gt; print(a)
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...
    ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
    ;; QUESTION SECTION:
    ;abc.com.                       IN      ANY
    ;; ANSWER SECTION:
    abc.com.                60      IN      A       1.2.3.4

Add additional RRs:

    &gt;&gt;&gt; a.add_answer(RR(&quot;xxx.abc.com&quot;,QTYPE.A,rdata=A(&quot;1.2.3.4&quot;)))
    &gt;&gt;&gt; a.add_answer(RR(&quot;xxx.abc.com&quot;,QTYPE.AAAA,rdata=AAAA(&quot;1234:5678::1&quot;)))
    &gt;&gt;&gt; str(DNSRecord.parse(a.pack())) == str(a)
    True
    &gt;&gt;&gt; print(a)
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...
    ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0
    ;; QUESTION SECTION:
    ;abc.com.                       IN      ANY
    ;; ANSWER SECTION:
    abc.com.                60      IN      A       1.2.3.4
    xxx.abc.com.            0       IN      A       1.2.3.4
    xxx.abc.com.            0       IN      AAAA    1234:5678::1


It is also possible to create a reply from a string in zone file format:

    &gt;&gt;&gt; q = DNSRecord(q=DNSQuestion(&quot;abc.com&quot;,QTYPE.ANY)) 
    &gt;&gt;&gt; a = q.replyZone(&quot;abc.com 60 IN CNAME xxx.abc.com&quot;)
    &gt;&gt;&gt; print(a)
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...
    ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
    ;; QUESTION SECTION:
    ;abc.com.                       IN      ANY
    ;; ANSWER SECTION:
    abc.com.                60      IN      CNAME   xxx.abc.com.

    &gt;&gt;&gt; str(DNSRecord.parse(a.pack())) == str(a)
    True

    &gt;&gt;&gt; q = DNSRecord(q=DNSQuestion(&quot;abc.com&quot;,QTYPE.ANY)) 
    &gt;&gt;&gt; a = q.replyZone(textwrap.dedent(z))
    &gt;&gt;&gt; print(a)
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...
    ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 0
    ;; QUESTION SECTION:
    ;abc.com.                       IN      ANY
    ;; ANSWER SECTION:
    abc.com.                300     IN      MX      10 mail.abc.com.
    www.abc.com.            300     IN      A       1.2.3.4
    www.abc.com.            300     IN      TXT     &quot;Some Text&quot;
    mail.abc.com.           300     IN      CNAME   www.abc.com.


The library also includes a simple framework for generating custom DNS
resolvers in dnslib.server (see module docs). In post cases this just 
requires implementing a custom 'resolve' method which receives a question 
object and returns a response.

A number of sample resolvers are provided as examples (see CLI --help):

 * dnslib.fixedresolver    - Respond to all requests with fixed response
 * dnslib.zoneresolver     - Respond from Zone file 
 * dnslib.shellresolver    - Call shell script to generate response

The library includes a number of client utilities:

 * DiG like client library 

        # python -m dnslib.client --help

 * DNS Proxy Server

        # python -m dnslib.proxy --help

 * Intercepting DNS Proxy Server (replace proxy responses for specified domains)

        # python -m dnslib.intercept --help


Changelog:
----------

 *   0.1     2010-09-19  Initial Release
 *   0.2     2010-09-22  Minor fixes
 *   0.3     2010-10-02  Add DNSLabel class to support arbitrary labels (embedded '.')
 *   0.4     2012-02-26  Merge with dbslib-circuits
 *   0.5     2012-09-13  Add support for RFC2136 DDNS updates
                         Patch provided by Wesley Shields &lt;wxs@FreeBSD.org&gt; - thanks
 *   0.6     2012-10-20  Basic AAAA support
 *   0.7     2012-10-20  Add initial EDNS0 support (untested)
 *   0.8     2012-11-04  Add support for NAPTR, Authority RR and additional RR
                         Patch provided by Stefan Andersson (https://bitbucket.org/norox) - thanks
 *   0.8.1   2012-11-05  Added NAPTR test case and fixed logic error
                         Patch provided by Stefan Andersson (https://bitbucket.org/norox) - thanks
 *   0.8.2   2012-11-11  Patch to fix IPv6 formatting
                         Patch provided by Torbjörn Lönnemark (https://bitbucket.org/tobbezz) - thanks
 *   0.8.3   2013-04-27  Don't parse rdata if rdlength is 0
                         Patch provided by Wesley Shields &lt;wxs@FreeBSD.org&gt; - thanks
 *   0.9.0   2014-05-05  Major update including Py3 support (see docs)
 *   0.9.1   2014-05-05  Minor fixes
 *   0.9.2   2014-08-26  Fix Bimap handling of unknown mappings to avoid exception in printing
                         Add typed attributes to classes
                         Misc fixes from James Mills - thanks
 *   0.9.3   2014-08-26  Workaround for argparse bug which raises AssertionError is [] is
                         present in option text (really?)

License:
--------

BSD

Author:
-------

 *   Paul Chakravarti (paul.chakravarti@gmail.com)

Master Repository/Issues:
-------------------------

 *   https://bitbucket.org/paulc/dnslib
    (Cloned on GitHub: https://github.com/paulchakravarti/dnslib)</description>
	<gfxmonk:upstream id="dnslib" type="pypi"/>
</interface>
<!-- Base64 Signature
iQEcBAABAgAGBQJUSFZFAAoJELrnGdQBsyfGEYAH/jRV6AQWUwX7SHBth0L20zC1xIzPOuLqSW70
ylZx7Zoj2twJJz3PcwtHaE1BaPTQFVrO2iKS18IjHhHI+pgM/zTcOtFtewN/mOyglfo+yjeIaIOd
79rR4AH8Heng4n9ZxU4RAHtcLk/2bhdpvqLVge4Z3XeUmOSCxat9CV4OauG6dBrK7nsGjHs6UosW
Y3/f4DWuEnfBzFIYClfyrOIV3g8BuwT75DaHusgJLfSeYypdMIbByrFAbgwI7w3TS9Tqne5M0hnF
fPmNdVYtnVHhYnv6KvBmIz34hI2Grt0dK5dowUof3jR4u9abpqt+38ULo+XYg+ZTlLiitUED4Ijs
iXI=

-->
